/*
student_utils.c
Автор: Кузнецов Александр

Задача: Проверить, есть ли в файле два ученика, которые:
    - Имеют одинаковое имя,
    - Имеют одинаковую фамилию,
    - Учатся в одном классе (например, 7А),
    - То есть — это один и тот же человек, записанный дважды.

Функция возвращает:
    1 — если нашла хотя бы одного дубликата (два одинаковых ученика)
    0 — если дубликатов нет, или если файл не открылся (ошибка)

Как работает:
    1. Открывает файл для чтения (первый ученик).
    2. Для каждого ученика снова открывает файл (второй проход).
    3. Сравнивает его с остальными учениками.
    4. Если найдёт совпадение — сразу возвращает 1.
    5. Если весь файл пройден — значит, дубликатов нет.
*/

#include "student_utils.h"  // Здесь описано, что существует функция has_duplicate_names_in_class
#include <stdio.h>          // Нужно для fopen, fscanf, fclose
#include <string.h>         // Нужно для strcmp — сравнивает строки (имена и фамилии)

// Структура — это как карточка ученика. У каждой карточки есть поля.
typedef struct {
    char name[64];      // Имя — максимум 63 буквы + 1 символ для конца строки
    char surname[64];   // Фамилия — тоже максимум 63 буквы
    int grade;          // Номер класса: 5, 7, 9, 11 — это обычные числа
    char section[8];    // Буква класса: "А", "Б", "В" — максимум 7 символов
} Student;

/*

Функция: is_equal
Назначение: Сравнить двух учеников — они одинаковые или нет?

Параметры:
    a — указатель на первого ученика (первую карточку)
    b — указатель на второго ученика (вторую карточку)

Что делает:
    Сравнивает:
        - Имя - совпадает?
        - Фамилия - совпадает?
        - Класс - совпадает? (например, 7 == 7)
        - Буква - совпадает? (например, "А" == "А")

    Если всё совпадает — возвращает 1
    Если хоть что-то не совпадает — возвращает 0

Почему не просто a.name == b.name?
    Потому что в C строки — это массивы символов. Мы не можем сравнивать их через ==.
    Нужно использовать функцию strcmp() — она сравнивает по буквам.

    strcmp(a->name, b->name) == 0 — значит: "строки одинаковые"
    (если != 0 — значит, разные)

*/
int is_equal(const Student* a, const Student* b) {
    // Сравнивает имя
    if (strcmp(a->name, b->name) != 0) {
        return 0; // Имена разные — сразу возвращаем "нет"
    }

    // Сравнивает фамилию
    if (strcmp(a->surname, b->surname) != 0) {
        return 0; // Фамилии разные — сразу возвращаем "нет"
    }

    // Сравнивает номер класса
    if (a->grade != b->grade) {
        return 0; // Классы разные — сразу возвращаем "нет"
    }

    // Сравнивает букву класса
    if (strcmp(a->section, b->section) != 0) {
        return 0; // Буквы разные — сразу возвращаем "нет"
    }

    // Если дошли сюда — значит, всё совпало
    return 1; // Да, это один и тот же ученик
}

/*

Функция: has_duplicate_names_in_class
Назначение: Прочитать файл с учениками и проверить — есть ли в нём повторы?

Параметр:
    filename — имя файла, например: "f.txt"

Возвращает:
    1 — если нашёл хотя бы одного дубликата (один ученик записан дважды в одном классе)
    0 — если дубликатов нет, или если файл не смог открыть

Как работает:
    - Берём одного ученика (s1).
    - Для него открываем файл заново и ищем совпадение (s2).
    - Если нашли — сразу возвращаем 1.
    - Если прошли весь файл — переходим к следующему ученику.
    - Если дошли до конца файла — возвращаем 0.

*/
int has_duplicate_names_in_class(const char* filename) {

    //Пытается открыть файл для чтения
    FILE* file1 = fopen(filename, "r");
    if (file1 == NULL) {
        // Если файл не открылся — печатает понятную ошибку
        perror("Ошибка: не удалось открыть файл");
        return 0; // Возвращает 0 — ошибка, работать дальше нельзя
    }

    //Создаёт временную карточку ученика для первого прохода
    Student s1;

    int line1 = 0; // Номер строки для первого файла

    // w1
    //Читает первого ученика
    while (fscanf(file1, "%63s %63s %d %7s",
                  s1.name, s1.surname, &s1.grade, s1.section) == 4) {

                    // Увеличивает номер строки
                    line1++; 

                    //Открывает файл ещё раз для поиска совпадений
                    FILE* file2 = fopen(filename, "r");
                    if (file2 == NULL) {
                        perror("Ошибка: не удалось открыть файл");
                        fclose(file1);
                        return 0;
                    }

        //Создаёт временную карточку ученика для второго прохода
        Student s2;

        int line2 = 0; // Номер строки для второго файла

        // w2
        //Читает всех учеников из второго файла
        while (fscanf(file2, "%63s %63s %d %7s",
                      s2.name, s2.surname, &s2.grade, s2.section) == 4) {

                        line2++; // Номер строки во втором файле

            /*
                Чтобы не считать "самого себя" дубликатом, онон сравнивает:
                - если line1 != line2 (то есть разные строки)
                - и ученики совпадают (is_equal вернул 1)
                Тогда это действительно дубликат.
            */

            // Проверяет условие дубликата:
            // 1) line1 != line2 — значит, это не один и тот же ученик в одной строке
            // 2) is_equal(&s1, &s2) — проверка, совпадает ли имя, фамилия и класс

            if (line1 != line2 && is_equal(&s1, &s2)) {
                //Нашли дубликат
                fclose(file2); // Закрывает второй файл
                fclose(file1); // Закрывает второй файл
                return 1;      // Возвращает 1 (нашли дубликаты)
            }
        }

        //Закрывает второй файл — проверили все строки
        fclose(file2);
    }

    //Закрывает первый файл — проверили всех учеников
    fclose(file1);

    //Дубликатов не найдено
    return 0;
}
