/*
Назначение:
    Реализует базовые операции: создание узлов, добавление в конец, поиск хвоста, освобождение памяти.
Используемые библиотеки:
    stdio.h  — для вывода сообщений об ошибках.
    stdlib.h — для malloc, free, exit.
    list_utils.h — для определения структуры Node и типов.
*/

#include <stdio.h>
#include <stdlib.h>
#include "list_utils.h"

/*
Функция: create_node

Создаёт новый узел в динамической памяти и инициализирует его.

Алгоритм:
    1. Выделяет память под структуру Node.
    2. Проверяет успешность выделения.
    3. Инициализирует поля: value, prev, next.
    4. Возвращает указатель на новый узел.
Обработка ошибок:
    Если malloc вернул NULL — выводит сообщение и завершает программу.
 */

Node* create_node(DataType value) {
    Node* node = (Node*)malloc(sizeof(Node));  // Выделяет память под один узел (размер структуры Node)
    if (node == NULL) {                        // Проверяет, успешно ли выделена память
        fprintf(stderr, "Ошибка: не удалось выделить память под новый узел.\n");  // Если нет — выводит ошибку
        exit(1);                               // Аварийно завершает программу
    }
    node->value = value;                       // Записывает переданное значение в поле value узла
    node->prev = NULL;                         // Устанавливает указатель на предыдущий узел в NULL (новый узел пока один)
    node->next = NULL;                         // Устанавливает указатель на следующий узел в NULL
    return node;                               // Возвращает указатель на созданный узел
}

/*
Функция: append
 
Добавляет новый узел в конец двусвязного списка.
 
Алгоритм:
    1. Создаёт новый узел с заданным значением.
    2. Если список пуст — устанавливает его как голову.
    3. Иначе — находит текущий хвост и связывает его с новым узлом.

Особенности:
    Использует двойной указатель на head, чтобы обновить голову при добавлении первого элемента.
 */
void append(Node** head, DataType value) {
    Node* new_node = create_node(value);       // Создаёт новый узел с переданным значением

    if (*head == NULL) {                       // Если список пуст (голова — NULL)
        *head = new_node;                      // Новый узел становится головой списка
        return;                                // Выходит — больше делать нечего
    }

    Node* tail = *head;                        // Начинает с головы, чтобы найти хвост
    while (tail->next != NULL) {               // Пока у текущего узла есть следующий — идёт дальше
        tail = tail->next;                     // Переходит к следующему узлу
    }

    tail->next = new_node;                     // Присоединяет новый узел после текущего хвоста
    new_node->prev = tail;                     // Указывает, что предыдущий для нового узла — это старый хвост
}

/*
Функция: get_tail

Находит и возвращает указатель на последний узел списка.
 
Алгоритм:
    Проходит по списку от головы до узла, у которого next == NULL.

Возвращает:
    NULL — если список пуст.
    Указатель на последний узел — в противном случае.
 */
Node* get_tail(Node* head) {
    if (head == NULL) return NULL;             // Если список пуст — сразу возвращает NULL

    Node* tail = head;                         // Начинает с головы — предполагает, что она и есть хвост
    while (tail->next != NULL) {               // Пока у текущего узла есть следующий — идёт дальше
        tail = tail->next;                     // Переходит к следующему узлу
    }
    return tail;                               // Возвращает найденный хвост (у которого next == NULL)
}

/*
Функция: free_list

Освобождает всю память, занятую списком.
 
Алгоритм:
    Последовательно проходит по списку, сохраняя указатель на текущий узел,
    переходит к следующему, затем освобождает текущий.
 */
void free_list(Node* head) {
    Node* temp;                                // Временный указатель — чтобы не потерять следующий узел при удалении текущего
    while (head != NULL) {                     // Пока не дошли до конца списка (head != NULL)
        temp = head;                           // Запоминает текущий узел (который будет удалять)
        head = head->next;                     // Сдвигает head на следующий узел (чтобы его не потерять)
        free(temp);                            // Освобождает память, занятую запомненным узлом
    }
    // После цикла head == NULL — список полностью удалён
}