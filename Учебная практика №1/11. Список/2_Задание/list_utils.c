/*
list_utils.c — реализация функций для работы со списком

Задача: Реализовать базовые операции над двусвязным списком — создание узлов, добавление в конец, нахождение хвоста, освобождение памяти.

Использует:
    - malloc() — выделение памяти под новый узел или массив
    - free() — освобождение памяти, чтобы не было утечек
    - exit(1) — аварийный выход при ошибках
    - printf() — вывод сообщений об ошибках

Структура Node описана в list_utils.h — это "вагончик" списка, 
содержащий число, указатель на предыдущий и следующий вагончик.
*/

#include <stdio.h>   // Нужно для printf
#include <stdlib.h>  // Нужно для malloc, free, exit
#include "list_utils.h"  // Подключает описание структур и функций (заголовочный файл)

/*
Функция: create_node

Описание:
    Создаёт новый узел (вагончик) списка в динамической памяти.
    Кладёт в него переданное число (value).
    prev = NULL и next = NULL — потому что он пока "один".
    Возвращает адрес нового узла.

Назначение: 
    Это как "фабрика вагончиков". Каждый раз, когда нужно добавить число в список — вызываем эту функцию.

Параметры:
    value — число типа DataType (у нас это double), которое нужно положить в узел.

Возвращаемое значение:
    Указатель на новый узел (Node*). Если память не выделилась — программа завершится с ошибкой.

*/
Node* create_node(DataType value) {
    // Просит у операционной системы кусочек памяти, достаточный для одного узла (структуры Node)
    // malloc возвращает "сырой" адрес, поэтому мы приводим его к типу Node* — указатель на узел
    Node* new_node = (Node*)malloc(sizeof(Node));

    // Кладёт переданное число внутрь созданного узла
    new_node->value = value;

    // Устанавливает указатель prev в NULL 
    new_node->prev = NULL;

    // Устанавливает указатель next в NULL 
    new_node->next = NULL;

    // Возвращает адрес нового узла — чтобы его можно было прицепить к списку
    return new_node;
}

/*
Функция: append

Описание:
    Добавляет новый узел с числом value в КОНЕЦ существующего списка.
    Если список пуст — новый узел становится головой (первым элементом).
    Если список не пуст — идёт до последнего узла и прицепляет новый за ним.

Назначение: 
    Чтобы пользователь мог вводить числа одно за другим, и они сохранялись в порядке ввода.

Параметры:
    head — это указатель на указатель головы списка (Node**). 
           Нужен двойной указатель, потому что мы можем изменить саму голову (если список был пуст).
    value — число, которое нужно добавить в конец.

*/
void append(Node** head, DataType value) {
    // Создаёт новый узел с нужным числом — используем уже готовую функцию
    Node* new_node = create_node(value);

    // Если список пуст — голова указывает на новый узел
    if (*head == NULL) {
        *head = new_node;  // тогда новый узел становится головой
        return;            // и выходит — делать больше нечего
    }

    //Если список не пуст — нужно найти последний узел
    Node* tail = *head;

    // Цикл: пока у текущего узла есть следующий (next != NULL) — идёт дальше
    while (tail->next != NULL) {
        tail = tail->next;     // переходит к следующему узлу
    }

    // Теперь tail указывает на последний узел
    // делает связи
    tail->next = new_node;
    new_node->prev = tail;
}

/*
Функция: get_tail

Описание:
    Ищет последний элемент (хвост) двусвязного списка.
    Работает просто: идёт от головы (первого элемента) по цепочке next,
    пока не найдёт элемент, у которого next = NULL.
    Возвращает указатель на этот последний элемент.

Назначение:
    Иногда нужно знать не только первый элемент (голову), но и последний (хвост).
    Например, чтобы пройтись по списку с конца или прицепить новый элемент в конец.

Параметры:
    head — указатель на первый элемент списка (голову).
           Может быть NULL, если список пуст.

Возвращаемое значение:
    - NULL, если список пуст.
    - Указатель на последний элемент списка, если он есть.
*/
Node* get_tail(Node* head) {
    // Проверяет, пустой ли список.
    // Если head == NULL, значит, списка нет -> возвращаем NULL.
    if (head == NULL) return NULL;

    // Начинает с головы, предполагает, что пока хвост = голова
    Node* tail = head;

    // Пока у текущего узла есть следующий элемент — идёт дальше
    while (tail->next != NULL) {
        tail = tail->next;  // смещается на следующий узел
    }

    // Теперь tail указывает на последний узел, потому что его next = NULL
    return tail;
}


/*
Функция: free_list

Описание:
    Удаляет весь список из памяти по одному узлу.
    Начинает с головы, запоминает текущий узел, переходит к следующему, удаляет запомненный.
    Повторяет, пока список не закончится.

Параметры:
    head — указатель на первый узел списка.

*/
void free_list(Node* head) {
    Node* temp; // Временная переменная — чтобы запомнить узел, который собираемся удалить

    // Цикл: пока head не станет NULL (пока есть узлы в списке)
    while (head != NULL) {
        temp = head;          // запоминает текущий узел (который сейчас head)
        head = head->next;    // сдвигает head на следующий узел (чтобы не потерять его)
        free(temp);           // удаляет запомненный узел — освобождаем его память
    }

    // Когда head станет NULL — цикл завершится. Список полностью удалён.
}