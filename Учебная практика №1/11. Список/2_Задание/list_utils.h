/*
list_utils.h — заголовочный файл

Задача: Описать структуры данных и функции, которые будут использоваться в других .c файлах.

Назначение: 
    Это как "инструкция" для компилятора
    Подключается в list_utils.c и main.c с помощью #include "list_utils.h"

Использует:
    - typedef — чтобы переименовать double в DataType
    - struct Node — описание структуры узла списка
    - объявления функций — без тела, только сигнатуры

Особенности:
    #ifndef LIST_UTILS_H — защита от повторного включения. Если файл уже подключён — не подключать снова.
*/

#ifndef LIST_UTILS_H  // Если макрос LIST_UTILS_H ещё не определён — продолжает
#define LIST_UTILS_H  // Определяет его, чтобы в следующий раз условие не выполнилось

// Переименовывает тип double в DataType
typedef double DataType;

/*
Структура Node (узел двусвязного списка)

Описание:
    Это "вагончик" в цепочке (списке).
    Содержит:
        - value: число (типа DataType, т.е. double)
        - prev: указатель на предыдущий узел
        - next: указатель на следующий узел

Теперь у каждого узла есть связь не только вперёд, но и назад.
Это нужно для того, чтобы можно было одновременно идти
от головы и от хвоста (для вычисления суммы без массива).
*/
typedef struct Node {
    DataType value;         // Число, которое хранит этот узел
    struct Node* prev;      // Указатель на предыдущий узел списка (может быть NULL)
    struct Node* next;      // Указатель на следующий узел списка (может быть NULL)
} Node;

// Объявления функций — компилятор узнаёт, что такие функции существуют и как их вызывать
Node* create_node(DataType value);
void append(Node** head, DataType value);
Node* get_tail(Node* head);   // Функция возвращает последний элемент списка
void free_list(Node* head);

#endif // LIST_UTILS_H — конец защиты от повторного включения
